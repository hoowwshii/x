<!DOCTYPE html>
<html lang="el">
    <meta charset="UTF-8">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
    <title>Αποκαλύπτοντας τον Κώδικα Αποτελεσματικότητας: Ο Αναμφισβήτητος Ρόλος της Χρονικής Πολυπλοκότητας στην Ισχύ του Αλγορίθμου</title>
</head>
<script>
    function myFunction() {
      document.getElementById("myDropdown").classList.toggle("show");
    }
    
    // Close the dropdown menu if the user clicks outside of it
    window.onclick = function(event) {
      if (!event.target.matches('.dropbtn')) {
        var dropdowns = document.getElementsByClassName("dropdown-content");
        var i;
        for (i = 0; i < dropdowns.length; i++) {
          var openDropdown = dropdowns[i];
          if (openDropdown.classList.contains('show')) {
            openDropdown.classList.remove('show');
          }
        }
      }
    } 
    
    </script>
<style>
    pre{
        border: 2px lightgray solid;
    }
    img{
        width: 150px;
        height: 200px;
        padding: 3px;
        
    }
    div{
        justify-content: center;
    }
    .tsrslt{
        width: 500px;
        height: 300px;
    }
    
    .dropbtn {
  background-color: #3498DB;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
  cursor: pointer;
}

/* Dropdown button on hover & focus */
.dropbtn:hover, .dropbtn:focus {
  background-color: #2980B9;
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
  position: relative;
  display: inline-block;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

/* Links inside the dropdown */
.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

/* Change color of dropdown links on hover */
.dropdown-content a:hover {background-color: #ddd;}

/* Show the dropdown menu (use JS to add this class to the .dropdown-content container when the user clicks on the dropdown button) */
.show {display:block;}
    table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
            }
    
            th, td {
                border: 1px solid #ddd;
                padding: 12px;
                text-align: center;
            }
    
            th {
                background-color: #f2f2f2;
                color: #333;
                font-weight: bold;
            }
    
            tr:nth-child(even) {
                background-color: #f9f9f9;
            }
    
            tr:hover {
                background-color: #f1f1f1;
            }
        p, h3{
            font-size: larger;
        }
    body{
    margin: 1.5in;
    text-align: justify;
    font-family: 'Noto Sans Serif';
    }
    </style>

<body>

    <h1 style="text-align: center;">Αποκαλύπτοντας τον Κώδικα Αποτελεσματικότητας: Ο Αναμφισβήτητος Ρόλος της Χρονικής Πολυπλοκότητας στην Ισχύ του Αλγορίθμου</h1>
    <p style="text-align: center;">李嘉强<br>2024</p>

    <h2>Κεφάλαιο 1: Εισαγωγή</h2>

    <h3>i. Ορισμός</h3>
    <p>
        Ένας αλγόριθμος είναι μια καλά καθορισμένη, βήμα προς βήμα υπολογιστική διαδικασία που χρησιμοποιείται για την επίλυση ενός συγκεκριμένου έργου ή προβλήματος. Ο αλγόριθμος λαμβάνει ορισμένες τιμές ή ένα σύνολο τιμών ως είσοδο και παράγει ορισμένες τιμές ή ένα σύνολο τιμών ως έξοδο. Από την άλλη πλευρά, ο αλγόριθμος είναι επίσης ένα εργαλείο για την επίλυση ενός καλά καθορισμένου υπολογιστικού προβλήματος. Αυτό το δοκίμιο επικεντρώνεται συγκεκριμένα στους αλγόριθμους ταξινόμησης.
    </p>

    <h3>ii. Χρονική και Χωρική Πολυπλοκότητα</h3>
    <p>
        Θεωρητικά, η χρονική πολυπλοκότητα είναι η υπολογιστική πολυπλοκότητα που περιγράφει την εκτίμηση του χρόνου που χρειάζεται για να ολοκληρωθεί ένας αλγόριθμος. Η πολυπλοκότητα μπορεί να θεωρηθεί ως ο μέγιστος αριθμός λειτουργιών που μπορεί να εκτελέσει ένα πρόγραμμα. Εκφράσεις όπως η πρόσθεση, η αφαίρεση, ο πολλαπλασιασμός και η ανάθεση μπορούν να αγνοηθούν ή να μην καταμετρηθούν. Υπάρχουν τρεις τύποι χρονικής πολυπλοκότητας: η σημειογραφία Big O για τον πιο αργό χρόνο ή το χειρότερο σενάριο, η Big Theta(Θ) αντιπροσωπεύει τον μέσο χρόνο και η Big Omega(Ω) αντιπροσωπεύει τον ταχύτερο χρόνο ή το καλύτερο σενάριο. Η πιο χρησιμοποιούμενη είναι η σημειογραφία Big O. Ο λόγος για τη χρήση της σημειογραφίας Big-O είναι επειδή υπάρχουν πολλοί παράγοντες όπως η υλοποίηση της γλώσσας προγραμματισμού, ο μεταγλωττιστής ή ο διερμηνέας, η ταχύτητα της μνήμης, το λειτουργικό σύστημα, οι άλλες διεργασίες που εκτελούνται στον υπολογιστή και πολλά άλλα. Επομένως, δεν θα έχει νόημα να δοθεί ένας ακριβής φυσικός χρόνος εκτέλεσης.
    </p>
    <ul>
        <li><b>O(1) - Σταθερός Χρόνος</b>: Ο αλγόριθμος σταθερού χρόνου θα χρειάζεται πάντα τον ίδιο χρόνο για να εκτελεστεί. Η εκτέλεση δεν εξαρτάται από το μέγεθος της εισόδου. Η εκτέλεση σταθερού χρόνου είναι σχεδόν στιγμιαία. Για παράδειγμα, το μέγεθος της εισόδου είναι 1000, η εκτέλεση του αλγορίθμου δεν επηρεάζεται από την είσοδο, πράγμα που σημαίνει ότι θα εκτελεστεί σε 1 λειτουργία.</li>
        <li><b>O(n) – Γραμμικός Χρόνος</b>: Ο αλγόριθμος γραμμικού χρόνου εξαρτάται από το μέγεθος της εισόδου. Ο χρόνος εκτέλεσης του αλγορίθμου γραμμικού χρόνου αυξάνεται καθώς το μέγεθος εισόδου(n) αυξάνεται με γραμμικό ρυθμό. Το παράδειγμα ενός αλγορίθμου γραμμικού χρόνου είναι ένας μοναδικός βρόχος for που επαναλαμβάνεται από το μηδέν έως το n. Για παράδειγμα, το μέγεθος της εισόδου είναι 1000, ο αλγόριθμος θα εκτελεστεί σε 1000 λειτουργίες/επανάληψη.</li>
        <li><b>O(log n) – Λογαριθμικός Χρόνος</b>: Ο αλγόριθμος λογαριθμικού χρόνου χρόνος εκτέλεσης είναι ανάλογος του λογαρίθμου βάσης δύο του μεγέθους της εισόδου n. Το παράδειγμα αλγορίθμου λογαριθμικού χρόνου είναι η δυαδική αναζήτηση, όπου το μέγεθος του προβλήματος μειώνεται επανειλημμένα στο μισό μέχρι να βρεθεί η λύση. Για παράδειγμα, το μέγεθος της εισόδου είναι 1000, ο αλγόριθμος θα εκτελεστεί σε περίπου 10 λειτουργίες/επανάληψη.</li>
        <li><b>O(n²) – Τετραγωνικός Χρόνος</b>: Ο αλγόριθμος τετραγωνικού χρόνου χρόνος εκτέλεσης είναι ανάλογος του τετραγώνου της εισόδου. Το παράδειγμα του αλγορίθμου τετραγωνικού χρόνου είναι ένας εμφωλευμένος βρόχος for έως ότου και οι δύο βρόχοι φτάσουν στο n. Για παράδειγμα, το μέγεθος της εισόδου είναι 1000, ο αλγόριθμος θα εκτελεστεί σε 1.000.000 λειτουργίες/επανάληψη.</li>
        <li><b>O(n log n)</b>: Ένας αλγόριθμος O(n log n) έχει χρόνο εκτέλεσης που αυξάνεται ανάλογα με το μέγεθος εισόδου n πολλαπλασιαζόμενο με τον λογάριθμο του n. Ένα κοινό παράδειγμα αυτού του αλγορίθμου είναι η ταξινόμηση συγχώνευσης, η οποία περιλαμβάνει τη διαίρεση της εισόδου και στη συνέχεια τη συγχώνευση των ταξινομημένων μισών. Εάν το μέγεθος της εισόδου είναι 1000, ο αλγόριθμος θα εκτελεστεί σε περίπου 10.000 λειτουργίες/επανάληψη.</li>
    </ul>

    <h3>iii. Σημειογραφία Big-O και Χρόνος Εκτέλεσης Αλγορίθμου</h3>
    <p>
        Γενικά, είναι δύσκολο να υπολογιστεί ο ακριβής χρόνος εκτέλεσης ενός αλγορίθμου, υπάρχουν πολλοί παράγοντες που μπορούν να επηρεάσουν τον χρόνο εκτέλεσης ενός αλγορίθμου, όπως η υλοποίηση της γλώσσας προγραμματισμού, ο μεταγλωττιστής ή ο διερμηνέας, η ταχύτητα της μνήμης, το λειτουργικό σύστημα, οι άλλες διεργασίες που εκτελούνται στον υπολογιστή. Ωστόσο, με τη βοήθεια της χρονικής πολυπλοκότητας, μπορεί να υπολογιστεί μια εκτίμηση του χρόνου εκτέλεσης ενός αλγορίθμου. Καθώς τα δεδομένα συνεχίζουν να αυξάνονται, η ικανότητα σχεδίασης καλών και αποτελεσματικών αλγορίθμων γίνεται ολοένα και πιο κρίσιμη.
    </p>

    <h3>iv. Υπόθεση</h3>
    <p>
       Σε μικρότερα σύνολα δεδομένων, οι διαφορές μεταξύ O(n²) και O(n) μπορεί να είναι ελάχιστες. Ωστόσο, με μεγαλύτερα σύνολα δεδομένων, η διαφορά γίνεται σημαντική. Με μια καλύτερη χρονική πολυπλοκότητα αλγορίθμου, θα είναι πιο αποτελεσματικό να επεξεργαστείτε μεγάλα σύνολα δεδομένων. Η επεξεργασία εκατομμυρίων ή δισεκατομμυρίων δεδομένων με έναν αναποτελεσματικό αλγόριθμο μπορεί να διαρκέσει ημέρες ή χρόνια ή ακόμα και για πάντα. Ένας αποτελεσματικός αλγόριθμος σε οποιαδήποτε προδιαγραφή υπολογιστή θα ξεπεράσει έναν αναποτελεσματικό αλγόριθμο σε έναν υπολογιστή υψηλής τεχνολογίας.
    </p>

    <h2>Κεφάλαιο 2: Αλγόριθμος</h2>

    <h3>i. Ταξινόμηση Φυσαλίδας</h3>
     <p>
        Η ταξινόμηση φυσαλίδας είναι ο απλούστερος αλγόριθμος ταξινόμησης που λειτουργεί επαναλαμβάνοντας την εναλλαγή των γειτονικών στοιχείων εάν αυτά βρίσκονται σε λάθος σειρά. Αυτός ο αλγόριθμος είναι αργός και εξαιρετικά αναποτελεσματικός, έχει τετραγωνική χρονική πολυπλοκότητα ή O(n²).
    </p>
    <ul>
        <li>Ξεκινά συγκρίνοντας τα δύο πρώτα στοιχεία. Εάν βρίσκονται σε λάθος σειρά, ανταλλάξτε τα.</li>
        <li>Συνεχίστε αυτή τη διαδικασία για όλα τα στοιχεία που κινούνται από αριστερά προς τα δεξιά.</li>
        <li>Στην επόμενη διαδρομή, παραλείψτε το τελευταίο στοιχείο, καθώς έχει ήδη ταξινομηθεί και επαναλάβετε τα παραπάνω βήματα</li>
       <li>Επαναλάβετε τα βήματα έως ότου ολόκληρος ο πίνακας είναι κατά σειρά.</li>
    </ul>

    <p>Ο ψευδοκώδικας του αλγορίθμου ταξινόμησης φυσαλίδας είναι:</p>
    <pre><code>
        Bubble-sort(A, n)
            for i = 1 to n-1
                for j = n to i+1
                    if A[j] < A[j - 1]
                        swap A[j] with A[j – 1]
    </code></pre>
    <p>一个随机顺序的小数据集。</p>
    <p>第一步：检查和交换。</p>
    <div style="display: flex;"><img src="array.png" alt=""></div>
    <p>第二步：更多的检查和交换。</p>
    <div style="display: flex;">
        <img src="bu1.png" alt="">
        <img src="bu2.png" alt="">
    </div>
    <p>第三步：更多的检查但是没有交换。40在正确的位置了</p>
    <div style="display: flex;">
        <img src="bu3.png" alt="">
        <img src="bu4.png" alt="">
    </div>
    <p>第四步：更多的检查和交换后,算法完成了</p>
    <div style="display: flex;">
        <img src="bu5.png" alt="">
        <img src="bu6.png" alt="">
    </div>
   <h3>ii. Ταξινόμηση Συγχώνευσης</h3>
    <p>
        Η ταξινόμηση συγχώνευσης είναι ένας αλγόριθμος ταξινόμησης που χρησιμοποιεί την προσέγγιση διαίρει και βασίλευε. Λειτουργεί διαιρώντας αναδρομικά τον πίνακα εισόδου σε μικρότερους υποπίνακες, ταξινομώντας αυτούς τους υποπίνακες και στη συνέχεια συγχωνεύοντάς τους ξανά για να λάβετε τον ταξινομημένο πίνακα. Αυτός ο αλγόριθμος είναι σχετικά γρήγορος με μέση χρονική πολυπλοκότητα O(n log n).
    </p>
    <ul>
        <li>Διαχωρίστε αναδρομικά τον πίνακα σε δύο μισά μέχρι να είναι αδύνατη η περαιτέρω διαίρεση.</li>
        <li>Ταξινομήστε κάθε υποπίνακα χρησιμοποιώντας τον αλγόριθμο ταξινόμησης συγχώνευσης.</li>
    </ul>
     <p>Συγχωνεύστε τους ταξινομημένους υποπίνακες σε έναν πίνακα.</p>

      <p>Ο ψευδοκώδικας του αλγορίθμου ταξινόμησης συγχώνευσης είναι:</p>
     <pre><code>
        Merge-sort(A,p,r)
            if p>= r
                return
            q = [(p+r)/2]
            Merge-sort(A,p,q)
            Merge-sort(A,q+1,r)
            Merge(A,p,q,r)

        Merge(A,p,q,r)
            n1=q-p+1
            n2=r-q
            let L[n1 – 1] and R[n2 – 1]
            for I = 0 to n1 – 1
                L[i] = A[p + i]
            for j = 0 to n2 – 1
                R[j] = A[q + j + 1]
            i=0
            j=0
            k=p
            while i<"n1" and j<"n2"
                if L[i] <= R[j]
                    A[k] = L[i]
                    I = i+1
                else A[k] = R[j]
                    j = j+1
                k = k+1
            while i < n1
                A[k] = L[i]
                I=i+1
                K=k+1
            while j < n2
                A[k] = R[j]
                j = j+1
                k = k+1
    </code></pre>

       <p>Η απεικόνιση της ταξινόμησης συγχώνευσης. Ο συγγραφέας προσπάθησε να κάνει την απεικόνιση με τον ίδιο τρόπο όπως η ταξινόμηση φυσαλίδας, αλλά τον τρομοκρατεί.</p>
       <div style="display: flex;"><img src="array.png" alt=""></div>
       <p>Ο ίδιος πίνακας με το παράδειγμα που χρησιμοποιήθηκε στην απεικόνιση της ταξινόμησης φυσαλίδας.</p>
       <div style="display: flex;"><img src="me1.png" alt=""></div>

       <p>Πρώτο βήμα: χωρίστε τον πίνακα σε 2 μέρη.</p>
       <div style="display: flex;"><img src="me2.png" alt=""></div>

       <p>Δεύτερο βήμα: χωρίστε τον πίνακα ακόμη περισσότερο, θα μπορούσε να χωριστεί μέχρι το μήκος του πίνακα να είναι 1.</p>
       <div style="display: flex;"><img src="me3.png" alt=""></div>

       <p>Τρίτο βήμα: αφού το 23 είναι μεγαλύτερο από το 18, παίρνουμε το 18.</p>
       <div style="display: flex;"><img src="me4.png" alt=""></div>

       <p>Τέταρτο βήμα: αφού η δεξιά διαμέριση είναι άδεια, παίρνουμε το 23.</p>
       
       <p>Πέμπτο βήμα: αντιγράψτε τα στοιχεία από τον νέο πίνακα πίσω στον αρχικό πίνακα.</p>
       <div style="display: flex;"><img src="me5.png" alt=""></div>

       <p>Έκτο βήμα: κάντε το ίδιο πράγμα όπως το βήμα 1 έως το βήμα 5, για τη δεξιά διαμέριση.</p>
       <div style="display: flex;">
        <img src="me6.png" alt="">
        <img src="me7.png" alt="">
        <img src="me8.png" alt="">
    </div>
       <p>Έβδομο βήμα: συγχώνευση.</p>
       <div style="display: flex;"><img src="me9.png" alt=""></div>

       <p>Όγδοο βήμα: αντιγράψτε τα στοιχεία από τον νέο πίνακα στον αρχικό πίνακα. Ο πίνακας έχει ταξινομηθεί.</p>


    <h3>iii. Γρήγορη Ταξινόμηση</h3>
    <p>
        Η γρήγορη ταξινόμηση, όπως η ταξινόμηση συγχώνευσης, είναι ένας αλγόριθμος διαίρει και βασίλευε. Επιλέγει ένα στοιχείο ως άξονα και χωρίζει τον δεδομένο πίνακα γύρω από τον άξονα τοποθετώντας τον άξονα στη σωστή του θέση στον υποπίνακα. Έχει μέση χρονική πολυπλοκότητα με O(n log n), ωστόσο έχει χρονική πολυπλοκότητα χειρότερης περίπτωσης τετραγωνικής χρονικής πολυπλοκότητας ή O(n²). Το πλεονέκτημα του αλγορίθμου γρήγορης ταξινόμησης είναι ότι είναι αποτελεσματικός σε μεγάλα σύνολα δεδομένων και καθώς αυτός ο αλγόριθμος είναι ένας αλγόριθμος διαίρει και βασίλευε, είναι ευκολότερο να λυθούν προβλήματα.
    </p>
    <ul>
        <li>Επιλέξτε έναν άξονα, είτε επιλέξτε το πρώτο ή το τελευταίο στοιχείο του πίνακα ή επιλέξτε ένα τυχαίο στοιχείο ως άξονα.</li>
        <li>Διαιρέστε χωρίζοντας τον πίνακα σε δύο υποπίνακες, την χαμηλή πλευρά (A[p:q - 1]), οι τιμές είναι μικρότερες από τον άξονα και την υψηλή πλευρά (A[q + 1:r]), οι τιμές είναι μεγαλύτερες από τον άξονα.</li>
        <li>Καλώντας τη γρήγορη ταξινόμηση αναδρομικά για την ταξινόμηση κάθε υποπίνακα, τη χαμηλή πλευρά και την υψηλή πλευρά.</li>
        <li>Σταματήστε την αναδρομή όταν υπάρχει μόνο ένα στοιχείο.</li>
    </ul>

    <p>Ο ψευδοκώδικας της γρήγορης ταξινόμησης είναι:</p>
    <pre><code>
        Quick-sort (A,p,r)
            if p <"r"
                q = Partition(A,p,r)
                Quick-sort (A,p,q-1)
                Quick-sort(A,q+1,r)

        Partition (A,p,r)
            x = A[r]
            i=p-1
            for j = ptor – 1
                if A[j] <= x
                    i=i+1
                    swap A[i] with A[j]
            swap A[i+1] with A[r]
            return i+1
    </code></pre>

       <p>Ο ίδιος πίνακας με το παράδειγμα που χρησιμοποιήθηκε στην απεικόνιση της ταξινόμησης φυσαλίδας και της ταξινόμησης συγχώνευσης.</p>
       <div style="display: flex;"><img src="array.png" alt=""></div>

       <p>Πρώτο βήμα: ορίστε τον δείκτη 0 ως άξονα, συγκρίνετέ τον με τον δείκτη 1 και τον δείκτη 2.</p>
       <div style="display: flex;">
        <img src="q1.png" alt="">
        <img src="q2.png" alt="">
    </div>
       <p>Δεύτερο βήμα: έλεγχος εάν ο δείκτης 0 είναι μεγαλύτερος από τον δείκτη 3 και ολοκλήρωση της επανάληψης. Ο άξονας βρίσκεται πίσω από τον δείκτη 3 και ο άξονας βρίσκεται στην ταξινομημένη θέση.</p>
       <div style="display: flex;">
        <img src="q3.png" alt="">
        <img src="q4.png" alt="">
    </div>
       <p>Τρίτο βήμα: ορίστε τον άξονα στον δείκτη 0, σε σύγκριση με άλλα στοιχεία με τον ίδιο τρόπο όπως το βήμα 2.</p>
       <div style="display: flex;"><img src="q5.png" alt=""></div>
       
       <p>Τέταρτο βήμα: ο πίνακας έχει ταξινομηθεί.</p>
       <div style="display: flex;"><img src="q6.png" alt=""></div>

    <h2>Κεφάλαιο 3: Δοκιμή</h2>

    <h3>i. Μεθοδολογία Δοκιμής</h3>
     <p>
        Η δοκιμή γίνεται από δύο γλώσσες, C++ και Java. Και οι δύο κώδικες είναι παρόμοιοι και χρησιμοποιούν μόνο την απαραίτητη βιβλιοθήκη ή αρχείο κεφαλίδας και καμία βιβλιοθήκη τρίτων ή αρχείο κεφαλίδας για να εξασφαλιστεί η δικαιοσύνη και να ελαχιστοποιηθούν οι περιττές πτώσεις απόδοσης. Στον κώδικα C++, το σύνολο δεδομένων αντιπροσωπεύεται από έναν διανυσματικό χώρο και στην Java, το σύνολο δεδομένων αντιπροσωπεύεται από ένα ArrayList.
    </p>
    <p>
        Για το χρονόμετρο, το C++ χρησιμοποιεί high_resolution_clock που μπορεί να βρεθεί στο αρχείο κεφαλίδας chrono, καθώς η Java χρησιμοποιεί System.nanoTime(). Όλες οι δοκιμές γίνονται σε έναν πυρήνα, η δοκιμή εξαρτάται μόνο από την ταχύτητα ρολογιού της CPU και δεν γίνεται πολυνηματική επεξεργασία. Για φορητό υπολογιστή, η δοκιμή γίνεται όταν είναι συνδεδεμένο το τροφοδοτικό για να εξασφαλιστεί η βέλτιστη απόδοση.
    </p>
      <p>Υπάρχουν τρία σύνολα δεδομένων. Μικρό σύνολο δεδομένων για δεδομένα που δεν είναι τόσο μεγάλα, έχει 200 στοιχεία. Μεσαίου μεγέθους σύνολο δεδομένων που έχει 20.000 στοιχεία. Και μεγάλο σύνολο δεδομένων, το μεγάλο είναι ελαφρώς μεγαλύτερο από το μεσαίο, έχει 200.000 στοιχεία. Κάθε σύνολο δεδομένων είναι ένας τυχαία δημιουργημένος ακέραιος που έχει τιμή μεταξύ 1 και 1.000.000.000. Το σύνολο δεν είναι διαδοχικό.</p>

    <table border="1">
        <thead>
            <tr>
                <th>Αρ.</th>
                <th>Όνομα/Τύπος Κεντρικού Υπολογιστή</th>
                <th>Προδιαγραφή Κεντρικού Υπολογιστή</th>
                <th>Πληροφορίες Μεταγλωττιστή C++</th>
                <th>Πληροφορίες JDK</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
<<<<<<< HEAD
                <td>嘉强/Φορητός Υπολογιστής</td>
=======
                <td>Κάρβιν/Φορητός Υπολογιστής</td>
>>>>>>> 27d4f189c8bfbd880db4d0b4b08d505d851c8157
                 <td>5Ghz CPU 8GB DDR5 SSD Windows 11</td>
                <td>g++ 13.2.0</td>
                <td>OpenJDK 21</td>
            </tr>
             <tr>
                <td>2</td>
<<<<<<< HEAD
                <td>嘉强/Διακομιστής (Google Cloud Shell)</td>
=======
                <td>Κάρβιν/Διακομιστής (Google Cloud Shell)</td>
>>>>>>> 27d4f189c8bfbd880db4d0b4b08d505d851c8157
                 <td>2.2Ghz CPU 16GB απροσδιόριστο SSD Ubuntu 22.04 kernel 6.1</td>
                <td>g++ 11.4.0</td>
                <td>OpenJDK 17</td>
            </tr>
              <tr>
                <td>3</td>
                 <td></td>
                 <td></td>
                  <td></td>
                 <td></td>
            </tr>
             <tr>
                <td>4</td>
                <td>Virtualbox(Mac OS Mojave)</td>
                <td>4.0GHz, 5GB 1600Mhz</td>
                <td>Apple LLVM 10</td>
                <td>Java 8</td>
            </tr>
             <tr>
                <td>5</td>
                <td>Virtualbox(Arch linux)</td>
                <td>4.0Ghz, 5GB 5600Mhz</td>
                 <td>g++ 14.2</td>
                <td>Java 8</td>
            </tr>
        </tbody>
    </table>

    <h2>Κεφάλαιο 4: Αποτέλεσμα Δοκιμής</h2>

    <h3>i. Αποτέλεσμα Δοκιμής</h3>

    <img src="image1.png" alt="" class="tsrslt">
     <p>[Γράφημα αποτελέσματος δοκιμής C++]</p>
     
     <img src="image2.png" alt="" class="tsrslt">
    <p>[Γράφημα αποτελέσματος δοκιμής Java]</p>


    <table border="1">
    <thead>
        <tr>
            <th>Αλγόριθμος</th>
            <th colspan="3">C++</th>
            <th colspan="3">Java</th>
        </tr>
        <tr>
            <th></th>
            <th>Εκτέλεση 1 (200)</th>
            <th>Εκτέλεση 2 (20.000)</th>
            <th>Εκτέλεση 3 (200.000)</th>
             <th>Εκτέλεση 1 (200)</th>
            <th>Εκτέλεση 2 (20.000)</th>
            <th>Εκτέλεση 3 (200.000)</th>
        </tr>
    </thead>
    <tbody>
            <tr>
                <td>Ταξινόμηση Φυσαλίδας</td>
                <td>0.219</td>
                <td>2269.784</td>
                <td>143.534</td>
                 <td>6.189</td>
                <td>1968.862</td>
                <td>202042.468</td>
            </tr>
            <tr>
               <td>Ταξινόμηση Συγχώνευσης</td>
                <td>0.115</td>
                <td>11.337</td>
                <td>52.205</td>
                 <td>0.784</td>
                <td>34.748</td>
                <td>70.006</td>
            </tr>
           <tr>
               <td>Γρήγορη Ταξινόμηση</td>
                 <td>0.026</td>
                <td>5.186</td>
                 <td>143.534</td>
                 <td>0.473</td>
                <td>20.302</td>
                <td>68.986</td>
            </tr>
     </tbody>
    </table>

    <p>
      Από όλα τα αποτελέσματα, το αποτέλεσμα είναι προφανές και αναμενόμενο. Η ταξινόμηση φυσαλίδας είναι η πιο αργή μεταξύ της ταξινόμησης συγχώνευσης και της γρήγορης ταξινόμησης, είτε για μικρό, μεσαίο ή μεγάλο σύνολο δεδομένων. Η γρήγορη ταξινόμηση είναι περίπου 4.000 φορές πιο γρήγορη από την ταξινόμηση φυσαλίδας, 2,74 φορές πιο γρήγορη από την ταξινόμηση συγχώνευσης. Η ταξινόμηση συγχώνευσης είναι 1300 φορές πιο γρήγορη από την ταξινόμηση φυσαλίδας.
    </p>

    <p>
     Αν και η γρήγορη ταξινόμηση έχει τη χειρότερη περίπτωση O(n²), ως αποτέλεσμα της δοκιμής, δεν δείχνει τις αδυναμίες της σε όλη τη δοκιμή. Ξεπερνά την ταξινόμηση συγχώνευσης. Ωστόσο, μπορεί να είναι δύσκολο να επιλεγεί ο ιδανικός άξονας. Δεν είναι δυνατό να επιλεγεί ένας 100% σωστός άξονας όλη την ώρα.
    </p>
     <p>
      Ανεξάρτητα από τη γλώσσα προγραμματισμού, η ταξινόμηση συγχώνευσης και η γρήγορη ταξινόμηση είναι πάντα ανώτερες σε σύγκριση με την ταξινόμηση φυσαλίδας. Η ταχύτητα ρολογιού της CPU είναι 100% όλη την ώρα ανεξάρτητα από το λειτουργικό σύστημα που εκτελεί τον αλγόριθμο. Η ταχύτητα ρολογιού παρακολουθείται από τη διαχείριση εργασιών στα Windows, το htop στο Linux και τον διαχειριστή δραστηριότητας στο mac OS. Αυτό δείχνει ότι η CPU χρησιμοποιήθηκε πλήρως σε όλη τη διάρκεια της δοκιμής.
    </p>

    <h2>Κεφάλαιο 5: Συμπέρασμα</h2>

    <h3>i. Συμπέρασμα</h3>
    <p>
     Τα αποτελέσματα των δοκιμών καταλήγουν στο συμπέρασμα ότι η επιλογή αλγορίθμου παίζει καθοριστικό ρόλο στην απόδοση, ειδικά σε μεγάλα σύνολα δεδομένων. Ένας αργός υπολογιστής που εκτελεί έναν αποτελεσματικό αλγόριθμο θα ξεπεράσει έναν γρήγορο υπολογιστή που εκτελεί έναν αναποτελεσματικό αλγόριθμο.
    </p>

    <p>
        Η γρήγορη ταξινόμηση είναι ταχύτερη από την ταξινόμηση φυσαλίδας κατά περίπου 4.000 φορές και η ταξινόμηση συγχώνευσης κατά περίπου 2,74 φορές. Η γρήγορη ταξινόμηση είναι σαφώς ο νικητής εδώ.
    </p>

     <p>
       Στη σύγχρονη εποχή, τα δεδομένα αυξάνονται μαζικά και η επιλογή αποτελεσματικού αλγορίθμου είναι κρίσιμη για την επεξεργασία και την ανάλυση τεράστιων συνόλων δεδομένων σε εύλογο χρόνο. Η μικρή αναποτελεσματικότητα μπορεί να οδηγήσει σε μειονέκτημα, όπως αυξημένο κόστος, χρόνο και πολλά άλλα. Η επιλογή αλγορίθμου επηρεάζει την ικανότητα να χειριστεί αποτελεσματικά την πολυπλοκότητα των σύγχρονων συστημάτων δεδομένων.
    </p>

     <h2>Βιβλιογραφία</h2>
     <p>
        Demaine, E., Ku, J. και Solomon, J. (2020) 6.006 εισαγωγή στους αλγορίθμους, απαγγελία 1: Εισαγωγή στους αλγορίθμους: Ηλεκτρολόγων μηχανικών και επιστήμη υπολογιστών, MIT OpenCourseWare. Διατίθεται στη διεύθυνση:
    <a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/mit6_006s20_r01/">https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/mit6_006s20_r01/</a> (Πρόσβαση: 3 Σεπτεμβρίου 2024).
    </p>
     <p>
       Gregg, C. και Zelenski, J. (2020) Διάλεξη 5/15: Ταξινόμηση, CS106B Ταξινόμηση. Διατίθεται στη διεύθυνση:
    <a href="https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1206/lectures/sorting/">https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1206/lectures/sorting/</a> (Πρόσβαση: 17 Σεπτεμβρίου 2024).
    </p>
    <div class="dropdown">
        <button onclick="myFunction()" class="dropbtn">语言</button>
        <div id="myDropdown" class="dropdown-content">
          <a href="#"><img src="Flag_of_Greece.svg" alt="" style="height: 24px; width: 36px;"></a>
          <a href="index.html"><img src="XiJinpingSignature.svg" alt="" style="height: 24px; width: 36px;"></a>
<<<<<<< HEAD
          <a href="kr.html"><img src="firefox_mfzc82Jk3k.png" alt="아이유.jpg" style="height: 100%; width: 100%;"></a>
=======
>>>>>>> 27d4f189c8bfbd880db4d0b4b08d505d851c8157
        </div>
      </div> 
</body>
</html>