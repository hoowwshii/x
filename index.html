<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>揭开效率密码：算法能力中时间复杂度的不可否认的作用</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
</head>
<script>
function myFunction() {
  document.getElementById("myDropdown").classList.toggle("show");
}

// Close the dropdown menu if the user clicks outside of it
window.onclick = function(event) {
  if (!event.target.matches('.dropbtn')) {
    var dropdowns = document.getElementsByClassName("dropdown-content");
    var i;
    for (i = 0; i < dropdowns.length; i++) {
      var openDropdown = dropdowns[i];
      if (openDropdown.classList.contains('show')) {
        openDropdown.classList.remove('show');
      }
    }
  }
} 

</script>
<style>
pre{
    border: 2px lightgray solid;
}
img{
    width: 150px;
    height: 200px;
    padding: 3px;
    
}
div{
    justify-content: center;
}
.tsrslt{
    width: 500px;
    height: 300px;
}
.dropbtn {
  background-color: #3498DB;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
  cursor: pointer;
}

/* Dropdown button on hover & focus */
.dropbtn:hover, .dropbtn:focus {
  background-color: #2980B9;
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
  position: relative;
  display: inline-block;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

/* Links inside the dropdown */
.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

/* Change color of dropdown links on hover */
.dropdown-content a:hover {background-color: #ddd;}

/* Show the dropdown menu (use JS to add this class to the .dropdown-content container when the user clicks on the dropdown button) */
.show {display:block;}

table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
            color: #333;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: #f1f1f1;
        }
    p, h3{
        font-size: larger;
    }
    
</style>

<body style="margin: 1.5in; font-family: 'Noto Serif SC', serif; text-align: justify;">

    <h1 style="text-align: center;">揭开效率密码：算法能力中时间复杂度的不可否认的作用</h1>
    <p style="text-align: center; font-weight: bolder;">李嘉强<br>2024</p>

    <h2>第一章：引言</h2>

    <h3>i. 定义</h3>
    <p>
        算法是一个定义明确的、逐步的计算过程，用于解决特定的任务或问题。算法以一些值或一组值作为输入，并产生一些值或一组值作为输出。另一方面，算法也是解决明确定义的计算问题的工具。本文主要关注排序算法。
    </p>

    <h3>ii. 时间和空间复杂度</h3>
    <p>
        理论上，时间复杂度是描述算法完成所需时间估计的计算复杂度。复杂度可以看作是程序可能执行的最大操作次数。加法、减法、乘法和赋值等表达式可以忽略或不计算。时间复杂度有三种类型：大O表示最慢时间或最坏情况，大Theta(Θ)表示平均时间，大Omega(Ω)表示最快时间或最好情况。最常用的是大O符号。使用大O符号的原因是有很多因素，例如编程语言实现、编译器或解释器、内存速度、操作系统、计算机上运行的其他进程等等。因此，给出精确的物理运行时间是没有意义的。
    </p>
    <ul>
        <li><b>O(1) - 常数时间</b>：常数时间算法总是需要相同的时间来执行。执行时间不依赖于输入的大小。常数时间执行几乎是瞬间完成的。例如，输入大小为1000，算法的执行不受输入影响，意味着它会执行1次操作。</li>
        <li><b>O(n) – 线性时间</b>：线性时间算法的运行时间取决于输入的大小。线性时间算法的运行时间随着输入(n)的大小线性增加。线性时间算法的例子是从零到n循环的单个for循环。例如，输入大小为1000，算法将执行1000次操作/迭代。</li>
        <li><b>O(log n) – 对数时间</b>：对数时间算法的运行时间与输入大小n的以2为底的对数成比例。对数时间算法的例子是二分查找，其中问题大小反复减半，直到找到解决方案。例如，输入大小为1000，算法将执行大约10次操作/迭代。</li>
        <li><b>O(n²) – 二次时间</b>：二次时间算法的运行时间与输入的平方成比例。二次时间算法的例子是嵌套的for循环，直到两个循环都达到n。例如，输入大小为1000，算法将执行1,000,000次操作/迭代。</li>
        <li><b>O(n log n)</b>：O(n log n)算法的运行时间与输入大小n乘以n的对数成比例增长。该算法的一个常见例子是归并排序，它涉及到分割输入，然后合并排序后的两半。如果输入大小为1000，该算法将执行大约10,000次操作/迭代。</li>
    </ul>

    <h3>iii. 大O符号和算法运行时间</h3>
    <p>
        一般来说，很难计算算法的精确运行时间，因为有很多因素会影响算法的运行时间，例如编程语言实现、编译器或解释器、内存速度、操作系统、计算机上运行的其他进程。然而，借助时间复杂度，可以计算出算法运行时间的估计值。随着数据不断增长，设计良好高效的算法的能力变得越来越重要。
    </p>

    <h3>iv. 假设</h3>
    <p>
        在较小的数据集中，O(n²)和O(n)的差异可能很小。然而，在较大的数据集中，差异会变得显著。使用更好的算法时间复杂度，可以更有效地处理大数据集。使用低效的算法处理数百万或数十亿的数据可能需要几天或几年甚至永远。任何计算机规格的有效算法都将优于高端计算机中的低效算法。
    </p>

    <h2>第二章：算法</h2>

    <h3>i. 冒泡排序</h3>
    <p>
        冒泡排序是一种最简单的排序算法，它通过重复交换相邻的元素（如果它们的顺序错误）来工作。这个算法很慢而且非常低效，它具有二次时间复杂度或 O(n²)。
    </p>
    <ul>
        <li>它首先比较前两个元素。如果它们的顺序错误，则交换它们。</li>
        <li>继续此过程，从左到右移动所有元素。</li>
        <li>在下一轮中，跳过最后一个元素，因为它已经被排序，并重复上述步骤。</li>
        <li>重复这些步骤，直到整个数组按顺序排列。</li>
    </ul>

    <p>冒泡排序算法的伪代码是：</p>
    <pre><code>
        Bubble-sort(A, n)
            for i = 1 to n-1
                for j = n to i+1
                    if A[j] < A[j - 1]
                        swap A[j] with A[j – 1]
    </code></pre>
    <p>一个随机顺序的小数据集。</p>
    <p>第一步：检查和交换。</p>
    <div style="display: flex;"><img src="array.png" alt=""></div>
    <p>第二步：更多的检查和交换。</p>
    <div style="display: flex;">
        <img src="bu1.png" alt="">
        <img src="bu2.png" alt="">
    </div>
    <p>第三步：更多的检查但是没有交换。40在正确的位置了</p>
    <div style="display: flex;">
        <img src="bu3.png" alt="">
        <img src="bu4.png" alt="">
    </div>
    <p>第四步：更多的检查和交换后,算法完成了</p>
    <div style="display: flex;">
        <img src="bu5.png" alt="">
        <img src="bu6.png" alt="">
    </div>
    <h3>ii. 归并排序</h3>
    <p>
        归并排序是一种使用分而治之方法的排序算法。它的工作原理是将输入数组递归地划分为更小的子数组，对这些子数组进行排序，然后将它们合并在一起以获得排序后的数组。该算法相对较快，平均时间复杂度为O(n log n)。
    </p>
    <ul>
        <li>递归地将数组分割成两半，直到无法进一步分割。</li>
        <li>使用归并排序算法对每个子数组进行排序。</li>
    </ul>
    <p>将排序后的子数组合并到一个数组。</p>
    
           
<p>归并排序算法的伪代码是：</p>
     <pre><code>
        Merge-sort(A,p,r)
            if p>= r
                return
            q = [(p+r)/2]
            Merge-sort(A,p,q)
            Merge-sort(A,q+1,r)
            Merge(A,p,q,r)

        Merge(A,p,q,r)
            n1=q-p+1
            n2=r-q
            let L[n1 – 1] and R[n2 – 1]
            for I = 0 to n1 – 1
                L[i] = A[p + i]
            for j = 0 to n2 – 1
                R[j] = A[q + j + 1]
            i=0
            j=0
            k=p
            while i<"n1 & j<"n2"
                if L[i] <= R[j]
                    A[k] = L[i]
                    I = i+1
                else A[k] = R[j]
                    j = j+1
                k = k+1
            while i < n1
                A[k] = L[i]
                I=i+1
                K=k+1
            while j < n2
                A[k] = R[j]
                j = j+1
                k = k+1
    </code></pre>

    

    <p>归并排序的可视化。作者试图以与冒泡排序相同的方式进行可视化，但它让他感到恐惧。</p>
    <div style="display: flex;"><img src="array.png" alt=""></div>
    
    <p>与冒泡排序可视化中使用的示例相同的数组。</p>
    <div style="display: flex;"><img src="me1.png" alt=""></div>
    
    <p>第一步：将数组分成 2 部分。</p>
    <div style="display: flex;"><img src="me2.png" alt=""></div>
    
    <p>第二步：进一步分割数组，它可能会分割直到数组的长度为 1。</p>
    <div style="display: flex;"><img src="me3.png" alt=""></div>
    
    <p>第三步：由于23大于18，所以取18。</p>
    <div style="display: flex;"><img src="me4.png" alt=""></div>
    
    <p>第四步：由于右分区为空，所以取23。</p>
    
    <p>第五步：将新数组中的元素复制回原始数组。</p>
    <div style="display: flex;"><img src="me5.png" alt=""></div>
    
    <p>第六步：对于右分区，执行与步骤 1 到步骤 5 相同的事情。</p>
    <div style="display: flex;">
        <img src="me6.png" alt="">
        <img src="me7.png" alt="">
        <img src="me8.png" alt="">
    </div>
    <p>第七步：合并。</p>
    <div style="display: flex;"><img src="me9.png" alt=""></div>
    
    <p>第八步：将新数组中的元素复制到原始数组。数组已排序。</p>

    <h3>iii. 快速排序</h3>
    <p>
        快速排序，像归并排序一样，是一种分而治之的算法。它选取一个元素作为枢轴，并通过将枢轴放置在子数组中的正确位置，将给定数组围绕枢轴进行分区。它的平均情况时间复杂度为O(n log n)，但它的最坏情况时间复杂度为二次时间复杂度或O(n²)。快速排序算法的优点是它在大型数据集上效率很高，并且由于该算法是一种分而治之的算法，因此更容易解决问题。
    </p>
    <ul>
        <li>选择一个枢轴，可以选取数组的第一个或最后一个元素，或者选取一个随机元素作为枢轴。</li>
        <li>通过将数组划分为两个子数组来进行分区，低侧 (A[p:q - 1])，值小于枢轴，高侧 (A[q + 1:r])，值大于枢轴。</li>
        <li>递归地调用快速排序来对每个子数组进行排序，低侧和高侧。</li>
        <li>当只剩下一个元素时，停止递归。</li>
    </ul>

    <p>快速排序算法的伪代码是：</p>
    <pre><code>
        Quick-sort (A,p,r)
            if p <"r"
                q = Partition(A,p,r)
                Quick-sort (A,p,q-1)
                Quick-sort(A,q+1,r)

        Partition (A,p,r)
            x = A[r]
            i=p-1
            for j = ptor – 1
                if A[j] <= x
                    i=i+1
                    swap A[i] with A[j]
            swap A[i+1] with A[r]
            return i+1
    </code></pre>
    <div style="display: flex;"><img src="array.png" alt=""></div>
    
    <p>与冒泡排序和归并排序可视化中使用的示例相同的数组。</p>
    <div style="display: flex;">
        <img src="q1.png" alt="">
        <img src="q2.png" alt="">
    </div>
    <p>第一步：设置索引0为枢轴，将其与索引1和索引2进行比较。</p>
    <div style="display: flex;">
        <img src="q3.png" alt="">
        <img src="q4.png" alt="">
    </div>
    <p>第二步：检查索引0是否大于索引3并完成迭代。枢轴位于索引3之后，并且枢轴位于排序后的位置。</p>
    <div style="display: flex;"><img src="q5.png" alt=""></div>
    
    <p>第三步：将枢轴设置为索引 0，以与步骤 2 中相同的方式与其他元素进行比较。</p>
    <div style="display: flex;"><img src="q6.png" alt=""></div>
    
    <p>第四步：数组已排序。</p>

    <h2>第三章：测试</h2>

    <h3>i. 测试方法</h3>
    <p>
        测试由 C++ 和 Java 两种语言完成。两种代码相似，并且只使用必要的库或头文件，没有使用第三方库或头文件，以确保公平性并最大限度地减少不必要的性能下降。在 C++ 代码中，数据集由向量表示，在 Java 中，数据集由 ArrayList 表示。对于计时器，C++ 使用 high_resolution_clock，可以在 chrono 头文件中找到，而 Java 使用 System.nanoTime()。所有测试都在单核上完成，测试仅依赖于 CPU 时钟速度，没有进行多线程处理。对于笔记本电脑，测试是在电源适配器插入时完成的，以确保最佳性能。
    </p>

    <p>有三个数据集。小尺寸数据集用于不太大的数据，其中包含 200 个元素。中等尺寸数据集包含 20,000 个元素。大尺寸数据集，大尺寸比中等尺寸略大，其中包含 200,000 个元素。每个数据集都是随机生成的整数，其值介于 1 和 1,000,000,000 之间。该集合不是连续的。</p>

    <table border="1">
        <thead>
            <tr>
                <th>编号</th>
                <th>主机名称/类型</th>
                <th>主机规格</th>
                <th>C++ 编译器信息</th>
                <th>JDK 信息</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>卡文/笔记本电脑</td>
                <td>5Ghz CPU 8GB DDR5 SSD Windows 11</td>
                <td>g++ 13.2.0</td>
                <td>OpenJDK 21</td>
            </tr>
            <tr>
                 <td>2</td>
                <td>卡文/服务器 (Google Cloud Shell)</td>
                 <td>2.2Ghz CPU 16GB 未指定的 SSD Ubuntu 22.04 kernel 6.1</td>
                <td>g++ 11.4.0</td>
                <td>OpenJDK 17</td>
            </tr>
             <tr>
                <td>3</td>
                 <td></td>
                 <td></td>
                 <td></td>
                  <td></td>
            </tr>
            <tr>
                 <td>4</td>
                <td>Virtualbox(Mac OS Mojave)</td>
                <td>4.0GHz, 5GB 1600Mhz</td>
                <td>Apple LLVM 10</td>
                <td>Java 8</td>
            </tr>
            <tr>
                 <td>5</td>
                <td>Virtualbox(Arch linux)</td>
                <td>4.0Ghz, 5GB 5600Mhz</td>
                <td>g++ 14.2</td>
                <td>Java 8</td>
            </tr>
        </tbody>
    </table>

    <h2>第四章：测试结果</h2>

    <h3>i. 测试结果</h3>
    <img src="image1.png" alt="" class="tsrslt">
    <p style="margin-top: 0;">[C++测试结果的图表]</p>
    <img src="image2.png" alt="" class="tsrslt">
    <p style="margin-top: 0;">[Java测试结果的图表]</p>

    <table border="1">
    <thead>
        <tr>
            <th>算法</th>
            <th colspan="3">C++</th>
            <th colspan="3">Java</th>
        </tr>
        <tr>
            <th></th>
            <th>Run 1 (200)</th>
            <th>Run 2 (20,000)</th>
            <th>Run 3 (200,000)</th>
             <th>Run 1 (200)</th>
            <th>Run 2 (20,000)</th>
            <th>Run 3 (200,000)</th>
        </tr>
    </thead>
    <tbody>
            <tr>
                <td>冒泡排序</td>
                 <td>0.219</td>
                <td>2269.784</td>
                 <td>143.534</td>
                  <td>6.189</td>
                <td>1968.862</td>
                 <td>202042.468</td>
            </tr>
            <tr>
                 <td>归并排序</td>
                <td>0.115</td>
                <td>11.337</td>
                <td>52.205</td>
                <td>0.784</td>
                <td>34.748</td>
                <td>70.006</td>
            </tr>
            <tr>
                 <td>快速排序</td>
                <td>0.026</td>
                 <td>5.186</td>
                <td>143.534</td>
                <td>0.473</td>
                <td>20.302</td>
                 <td>68.986</td>
            </tr>
     </tbody>
    </table>

    <p>
    从所有结果来看，结果是显而易见的且符合预期的。冒泡排序是归并排序和快速排序中最慢的，无论是对于小型、中型还是大型数据集。快速排序比冒泡排序快大约 4,000 倍，比归并排序快 2.74 倍。归并排序比冒泡排序快 1300 倍。
    </p>
    <p>
    虽然快速排序的最坏情况为 O(n²)，但测试结果并没有显示其弱点。它的性能优于归并排序。然而，选择理想的枢轴可能很棘手。不可能一直选择 100% 正确的枢轴。
    </p>
    <p>
    无论使用哪种编程语言，如果与冒泡排序相比，归并排序和快速排序始终是更好的选择。CPU 时钟速度在任何时候都是 100%，无论运行该算法的操作系统如何。通过 Windows 上的任务管理器、Linux 上的 htop 以及 Mac OS 上的活动管理器监控时钟速度。这表明 CPU 在整个测试过程中都被充分利用。
    </p>

    <h2>第五章：结论</h2>

    <h3>i. 结论</h3>
    <p>
        测试结果得出结论，算法选择在决定性能方面起着至关重要的作用，尤其是在大型数据集上。运行高效算法的慢速计算机将优于运行低效算法的快速计算机。快速排序比冒泡排序快约 4,000 倍，归并排序快约 2.74 倍。快速排序显然是这里的赢家。
    </p>

    <p>
        在现代，数据呈大规模增长，选择高效的算法对于在合理的时间内处理和分析海量数据集至关重要。轻微的低效会导致诸如增加成本、时间和更多问题等劣势。算法选择会影响有效地处理现代数据系统复杂性的能力。
    </p>

    <h2>参考书目</h2>
   <p> Demaine, E., Ku, J. 和 Solomon, J. (2020) 6.006 算法导论，演讲 1：算法导论：电气工程和计算机科学，麻省理工学院开放课件。可在此处获取：
    <a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/mit6_006s20_r01/">https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/mit6_006s20_r01/</a> (访问日期：2024 年 9 月 3 日)。
    </p>
    <p>
    Gregg, C. 和 Zelenski, J. (2020) 讲座 5/15：排序，CS106B 排序。可在此处获取：
    <a href="https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1206/lectures/sorting/">https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1206/lectures/sorting/</a> (访问日期：2024 年 9 月 17 日)。
    </p>
    
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <!-- <iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/6f1bpsEpqSmvgL4QdEzKuo?utm_source=generator" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe> -->
    <div class="dropdown">
        <button onclick="myFunction()" class="dropbtn">语言</button>
        <div id="myDropdown" class="dropdown-content">
          <a href="gr.html"><img src="Flag_of_Greece.svg" alt="" style="height: 24px; width: 36px;"></a>
          <a href="#"><img src="XiJinpingSignature.svg" alt="" style="height: 24px; width: 36px;"></a>
          <a href="kr.html"><img src="firefox_mfzc82Jk3k.png" alt="아이유.jpg" style="height: 100%; width: 100%;"></a>
        </div>
      </div> 
    <br><br>
    <iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="450" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/id/playlist/%CF%83%CF%84%CE%AC%CF%83%CE%B7/pl.u-qxylEN5u3AdeW3X"></iframe>
    <p>这几首歌就是制作这篇文章的时候，我比较常听的几首歌。都是韩国流行音乐。</p>
    <iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="175" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/id/album/favorite-part/1650514335?i=1650514564"></iframe>
    <p>最最最喜欢的</p>
    
</body>
</html>
